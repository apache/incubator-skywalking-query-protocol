# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Metrics v2 query protocol is an alternative metrics query(s) of original v1,
# defined in the metric.graphql, top-n-records.graphqls, and aggregation.graphqls.
# By leveraging the new ID rule(no register) in the v8, we could query metrics based on name(s) directly.

input Entity {
    # 1. scope=All, no name is required.
    # 2. scope=Service, ServiceInstance and Endpoint, set neccessary serviceName/serviceInstanceName/endpointName
    # 3. Scope=ServiceRelation, ServiceInstanceRelation and EndpointRelation
    #    serviceName/serviceInstanceName/endpointName is/are the source(s)
    #    destServiceName/destServiceInstanceName/destEndpointName is/are destination(s)
    #    set necessary names of sources and destinations.
    scope: Scope!
    serviceName: String
    # Normal service is the service having installed agent or metrics reported directly.
    # Unnormal service is conjectural service, usually detected by the agent.
    isNormal: Boolean
    serviceInstanceName: String
    endpointName: String
    destServiceName: String
    # Normal service is the service having installed agent or metrics reported directly.
    # Unnormal service is conjectural service, usually detected by the agent.
    destIsNormal: Boolean
    destServiceInstanceName: String
    destEndpointName: String
}

input MetricsCondition {
    # Metrics name, which should be defined in OAL script
    # Such as:
    # Endpoint_avg = from(Endpoint.latency).avg()
    # Then, `Endpoint_avg`
    name: String!
    # Follow entity definition description.
    entity: Entity
}

input BatchMetricsConditions {
    # Metrics name, which should be defined in OAL script
    # Such as:
    # Endpoint_avg = from(Endpoint.latency).avg()
    # Then, `Endpoint_avg`
    name: String!
    # Follow entity definition description.
    ids: [Entity!]!
}

input TopNCondition {
    # Metrics name
    name: String!
    # Follow entity definition description.
    entity: Entity
    topN: Int!
    order: Order!
}

type MetricsDefintion {
    valueType: MetricsType
}

# Metrics type is a new concept since v8.
enum MetricsType {
    # Regular value type is suitable for getValuesByEntity, getLinearIntValuesByEntity
    REGULAR_VALUE
    HEATMAP
}

type HeatMap {
    # Each element in nodes represents a point in Thermodynamic Diagram
    # And the element includes three values:
    # 1) Time Bucket based on query duration
    # 2) Response time index.
    #    Response time = [responseTimeStep * index, responseTimeStep * (index+1))
    #    The last element: [Response Time * index, MAX)
    # 3) The number of calls in this response time duration.
    #
    # Example:
    # [ [0, 0, 10], [0, 1, 43], ...]
    # These ^^^ two represent the left bottom element, and another element above it.
    nodes: [[Int]!]!
    axisYStep: Int!
}

type TopNMetrics {
    name: String!
    id: ID!
    value: Long!
}

type TopNStatement {
    statement: String
    latency: Long!
    # Have value, Only if the record has the trace id.
    # Slow record
    traceId: String
}

extend type Query {
    getValuesByEntity(metrics: BatchMetricsConditions!, duration: Duration!): IntValues
    getLinearIntValuesByEntity(metrics: MetricsCondition!, duration: Duration!): IntValues
    # Query the type of metrics including multiple values, and format them as multiple linears.
    # The seq of these multiple lines base on the calculation func in OAL
    # Such as, should us this to query the result of func percentile(50,75,90,95,99) in OAL,
    # then five lines will be responsed, p50 is the first element of return value.
    getMultipleLinearIntValuesByEntity(metrics: MetricsCondition!, linearIndex: [Int!]!, duration: Duration!): [IntValues!]!
    getHeatmapByEntity(metrics: MetricsCondition!, duration: Duration!): HeatMap
    # Get TopN metrics values from the given entity and parameters.
    # The alternative query of get* in aggregation.graphqls
    getTopN(metrics: TopNCondition!, order: Order!): [TopNMetrics!]!
    # Get TopN statements from the given entity and parameters.
    # The alternative query of get* in top-n-records.graphqls
    getTopNStatements(metrics: TopNCondition!, order: Order!): [TopNStatement!]!
}